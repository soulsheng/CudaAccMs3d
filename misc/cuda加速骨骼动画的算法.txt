cuda加速骨骼动画的算法

一、问题建模
在使用计算机的前沿技术解决现实中的某个应用难题时，为了探索一套行之有效而又具有普遍参考价值的方案，需要先为问题的原型建立抽象的数学模型。本文的问题原型是如何提升计算机三维动画实时绘制的时间效率，其中：计算机三维动画以骨骼动画为例；实时绘制完整过程可以划分为以下三个环节，从文件解析并获取骨骼关节矩阵和顶点坐标，更新关节矩阵和顶点坐标，以动态三维纹理面片的方式输出顶点坐标最终形成三维动画；时间效率的指标是单位时间内实时绘制可被循环执行的次数。问题原型的核心是绘制过程，绘制过程的三个环节可以抽象为对两种数据结构的三种操作，其中数据结构指关节矩阵和顶点坐标，操作包含初始化矩阵和坐标、更新矩阵和坐标、输出坐标。
本文基于以上抽象模型展开一系列理论分析和实验印证，探索得到适用于抽象模型的解决方案，最终反馈到现实中的问题原型，通过实际应用进一步验证问题解决方案的可行性。
基于以上抽象模型，首先结合问题原型通过理论分析初步评估时间效率的瓶颈位置，然后通过实验进行验证，经过以上评估和验证的多次迭代，逐渐缩小瓶颈范围，最终得到粒度适中的瓶颈区域，以该区域作为优化目标进行优化，以求弱化或消除瓶颈。评估结论如下：1）第一个环节输入数据本身不占用实时计算时间；2）第二个环节更新数据占用绝大部分时间，进一步细分为关节矩阵更新和顶点更新两个步骤，顶点的数据规模远远大于关节，顶点的运算量和运算时间远远大于关节；3）第三个环节输出数据，占用很少的时间。进一步得出结论，瓶颈位置是顶点更新运算。本文接下来着重关注顶点更新运算，上游数据用模拟数据代替，并忽略下游结果输出。实验结束以后，将用真实骨骼动画数据进行验证。

二、数据结构

typedef float4 Vertex; // 坐标：(x,y,z);关节索引：w

struct Vertexes{

// 获取顶点坐标
void initialize(int size, float* pBufferPOS, int* pBufferIndex){
nSize = size;
pVertex = new Vertex[nSize];
for(int i=0;i<nSize;i++){
pVertex[i].x = pBufferPos[i*3];
pVertex[i].y = pBufferPos[i*3+1];
pVertex[i].z = pBufferPos[i*3+2];
pVertex[i].w = pBufferIndex[i];
}
}

Vertex*  pVertex;
int   nSize;// 顶点的数目

};// 顶点的集合

typedef float3[3]	MATRIX;// 矩阵

struct Joints{

// 获取关节矩阵
void initialize( int size, float* pBufferMAT ){
nSize = size;
pMat = new MATRIX[nSize];
memcpy( pMat, pBufferMAT, sizeof(MAT) * nSize );
}

MATRIX*  pMat;
int   nSize;// 关节的数目

};// 关节的集合

三、数据与算法
1、数据
Vertexes	_vertexes;
Joints		_joints;

2、算法
数据初始化


四、实验配置
1、运行环境
操作系统：Windows 7
显卡：Nvidia Geforce GTX 670（1344核）
CPU： Intel i7 3770k（4核）

2、编程环境
CUDA工具包：CUDA v4.2
编译工具：Visual Studio 2010

五、实验过程
